use std::fmt::Display;

#[derive(Debug, PartialEq, Clone, Eq, Hash)]
pub enum Token {
    And,
    AndAnd,
    AndEq,
    BraceClose,
    BraceOpen,
    Caret,
    CaretEq,
    Colon,
    Comma,
    Conjunction,
    Disjunction,
    Eq,
    EqEq,
    Exists,
    Forall,
    Ge,
    Gt,
    Implication,
    Le,
    Lt,
    MagicWand,
    Minus,
    MinusEq,
    Ne,
    Not,
    Or,
    OrEq,
    OrOr,
    ParenClose,
    ParenOpen,
    Percent,
    PercentEq,
    Plus,
    PlusEq,
    RArrow,
    Semi,
    Shl,
    ShlEq,
    Shr,
    ShrEq,
    Slash,
    SlashEq,
    Star,
    StarEq,
    StarStar,
    Assuming,
    Break,
    Continue,
    Else,
    Ergo,
    Fn,
    If,
    Let,
    Loop,
    Proof,
    Qed,
    Return,
    While,
    Ident,
    Number,
    Space,
    Comment,
    True,
    False,
}

impl Display for Token {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let tok = match self {
            Token::And => "`&`",
            Token::AndAnd => "`&&`",
            Token::AndEq => "`&=`",
            Token::BraceClose => "`}`",
            Token::BraceOpen => "`{`",
            Token::Caret => "`^`",
            Token::CaretEq => "`^=`",
            Token::Colon => "`:`",
            Token::Comma => "`,`",
            Token::Conjunction => "`∧`",
            Token::Disjunction => "`∨`",
            Token::Eq => "`=`",
            Token::EqEq => "`==`",
            Token::Exists => "`∃`",
            Token::Forall => "`∀`",
            Token::Ge => "`>=`",
            Token::Gt => "`>`",
            Token::Implication => "`⟶`",
            Token::Le => "`<=`",
            Token::Lt => "`<`",
            Token::MagicWand => "`--*`",
            Token::Minus => "`-`",
            Token::MinusEq => "`-=`",
            Token::Ne => "`!=`",
            Token::Not => "`!`",
            Token::Or => "`|`",
            Token::OrEq => "`|=`",
            Token::OrOr => "`||`",
            Token::ParenClose => "`)`",
            Token::ParenOpen => "`(`",
            Token::Percent => "`%`",
            Token::PercentEq => "`%=`",
            Token::Plus => "`+`",
            Token::PlusEq => "`+=`",
            Token::RArrow => "`->`",
            Token::Semi => "`;`",
            Token::Shl => "`<<`",
            Token::ShlEq => "`<<=`",
            Token::Shr => "`>>`",
            Token::ShrEq => "`>>=`",
            Token::Slash => "`\\`",
            Token::SlashEq => "`\\=`",
            Token::Star => "`*`",
            Token::StarEq => "`*=`",
            Token::StarStar => "`**`",
            Token::Assuming => "`assuming`",
            Token::Break => "`break`",
            Token::Continue => "`continue`",
            Token::Else => "`else`",
            Token::Ergo => "`ergo`",
            Token::Fn => "`fn`",
            Token::If => "`if`",
            Token::Let => "`let`",
            Token::Loop => "`loop`",
            Token::Proof => "`apply`",
            Token::Qed => "`qed`",
            Token::Return => "`return`",
            Token::While => "`while`",
            Token::Ident => "an identifier",
            Token::Number => "a number",
            Token::Space => "spaces",
            Token::Comment => "a comment",
            Token::True => "`true`",
            Token::False => "`false`",
        };
        write!(f, "{tok}")
    }
}
